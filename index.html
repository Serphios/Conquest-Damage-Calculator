<!DOCTYPE html>
<html>
<head>
  <title>Conquest Damage Calculator</title>
  <style>
  body {
    font-family: 'Segoe UI', sans-serif;
    background-color: #121212;
    color: #f0f0f0;
    margin: 0;
    padding: 20px;
  }

  .container {
    display: flex;
    flex-direction: column;
    gap: 30px;
    max-width: 1200px;
    margin: auto;
    padding-bottom: 50px;
  }

  .section {
    border-radius: 12px;
    padding: 20px;
    background-color: #1e1e1e;
  }

  .section-title {
    font-size: 20px;
    font-weight: bold;
    margin-bottom: 10px;
  }

  .input-group {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
  }

  .input-group label {
    flex: 1 1 300px;
    display: flex;
    flex-direction: column;
    font-size: 14px;
  }

  input, select, button {
    padding: 8px;
    margin-top: 5px;
    background-color: #2a2a2a;
    color: #ffffff;
    border: 1px solid #555;
    border-radius: 6px;
  }

  input:focus, select:focus, button:focus {
    outline: none;
    border-color: #888;
  }

  .attacker {
    border-left: 4px solid #3a9bff;
  }

  .defender {
    border-left: 4px solid #e45757;
  }

  button {
    background-color: #3a9bff;
    border: none;
    cursor: pointer;
  }

  button:hover {
    background-color: #2e7ccc;
  }

  .result {
    white-space: pre-line;
    background-color: #1b1b1b;
    padding: 20px;
    border-radius: 8px;
    border-left: 4px solid #4caf50;
    font-family: monospace;
  }
</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>Conquest Damage Calculator</h1>
  <div class="container">
    <div class="section attacker">
      <div class="section-title">Your Unit</div>
      <div class="input-group">
        <label>Total Stands:</label>
        <input type="number" id="models" value="3">
        <label>Stands in Contact:</label>
        <input type="number" id="standsInContact" value="3">
        <label>Support (for non-contact stands):</label>
        <input type="number" id="support" value="1">
        <label>Attacks per Stand:</label>
        <input type="number" id="attacks" value="4">
        <label>Impact Attacks per Stand:</label>
        <input type="number" id="impact" value="0">
        <label>Clash Value:</label>
        <input type="number" id="cllash" value="3">
        <label>Cleave:</label>
        <input type="number" id="cleave" value="0">
        <label>Brutal Impact:</label>
        <input type="number" id="brutalImpact" value="0">
        <label>Trample (per Stand):</label>
        <input type="number" id="trample" value="0">
        <label>Terrifying:</label>
        <input type="number" id="terrifying" value="0">
		

        <!-- Angreifer-Regeln -->
        <label><input type="checkbox" id="leader" checked> Add Leader (1 extra attack)</label>
        <label><input type="checkbox" id="inspired"> Inspired (Clash +1, max 4)</label>
        <!-- Rule Selection -->
<div>
  <label for="attackerSpecialRules">Add Special Rule:</label>
  <select id="attackerSpecialRules">
    <option value="">-- Select --</option>
    <option value="flurry">Flurry</option>
    <option value="relentless">Relentless Blows</option>
    <option value="smite">Smite</option>
    <option value="shock">Shock</option>
    <option value="deadlyBlades">Deadly Blades</option>
    <option value="gloriousCharge">Glorious Charge</option>
    <option value="linebreaker">Linebreaker</option>
    <option value="flawless">Flawless Strikes</option>
    <option value="blessed">Blessed</option>
    <option value="opportunists">Opportunists</option>
  </select>
  <button type="button" onclick="addAttackerRule()">Add</button>
</div>

<!-- Selected Rules Display -->
<ul id="attackerRulesList" style="margin-top: 10px; list-style: none; padding: 0;"></ul>

<!-- Blessed Usage Dropdown (hidden by default) -->
<div id="blessedUsageContainer" style="display: none; margin-top: 10px;">
  <label for="attackerBlessedUsage">Blessed Usage:</label>
  <select id="attackerBlessedUsage">
    <option value="none">None</option>
    <option value="normal">Normal Attack</option>
    <option value="impact">Impact Attack</option>
  </select>
</div>

<ul id="attackerRulesList" style="margin-top: 10px;"></ul>


      </div>
    </div>

    <div class="section defender">
      <div class="section-title">Opponent Unit</div>
      <div class="input-group">
        <label>Total Stands (Defender):</label>
        <input type="number" id="defenderStands" value="3">
        <label>Defense Value:</label>
        <input type="number" id="defense" value="2">
        <label>Evasion Value:</label>
        <input type="number" id="evasion" value="0">
        <label>Resolve Value:</label>
        <input type="number" id="resolve" value="2">
        <label>Hardened:</label>
        <input type="number" id="hardened" value="0">
        <label>Indomitable:</label>
        <input type="number" id="indomitable" value="0">
        <label>Bastion:</label>
        <input type="number" id="bastion" value="0">
		<label>Tenacious:</label>
		<input type="number" id="tenacious" value="0">


        <!-- Verteidiger-Regeln -->
        <label><input type="checkbox" id="flankRear"> Flank or Rear Attack</label>
        <label><input type="checkbox" id="ignoreResolve"> Ignore Resolve</label>
        <label><input type="checkbox" id="oblivious"> Oblivious (1 wound per 2 failed resolve checks)</label>
        <label><input type="checkbox" id="shield"> Shield (+1 Defense unless Flank/Rear)</label>
        <label><input type="checkbox" id="parry"> Parry (Attacker cannot reroll hit rolls)</label>
        <label><input type="checkbox" id="phalanx"> Phalanx (+1 Defense and Resolve if not Flank/Rear)</label>
        <label><input type="checkbox" id="duelDeclined"> Duel Declined (reroll resolve rolls of 1)</label>
		<label><input type="checkbox" id="untouchable"> Untouchable (Reroll failed defense rolls of 6)</label>
        <label>Defender Blessed Usage:</label>
        <select id="defenderBlessed">
          <option value="none">None</option>
          <option value="normal">Normal Attack</option>
          <option value="impact">Impact Attack</option>
        </select>
        <label>Bravery / Fearless:</label>
        <select id="bravery">
          <option value="none">None</option>
          <option value="bravery">Bravery</option>
          <option value="fearless">Fearless</option>
        </select>
      </div>
    </div>

    <div class="section">
      <button onclick="calculateDamage()">Calculate Damage</button>
	  <label><input type="checkbox" id="useSimulation"> Use Simulation (10,000 rolls)</label>
    </div>

    <div class="result" id="result"></div>
	<canvas id="woundChart" style="max-width: 1000px; margin-top: 30px;"></canvas>
  </div>
<script>
const activeAttackerRules = new Set();

function addAttackerRule() {
  const select = document.getElementById("attackerSpecialRules");
  const value = select.value;
  const text = select.options[select.selectedIndex].text;

  if (!value || activeAttackerRules.has(value)) return;

  activeAttackerRules.add(value);

  if (value === "blessed") {
    document.getElementById("blessedUsageContainer").style.display = "block";
  }

  const list = document.getElementById("attackerRulesList");
  const li = document.createElement("li");
  li.id = "rule_" + value;
  li.style.marginBottom = "5px";

  const label = document.createElement("span");
  label.textContent = text + " ";

  const removeBtn = document.createElement("button");
  removeBtn.textContent = "❌";
  removeBtn.style.marginLeft = "10px";
  removeBtn.onclick = () => {
    activeAttackerRules.delete(value);
    document.getElementById("rule_" + value).remove();
    if (value === "blessed") {
      document.getElementById("blessedUsageContainer").style.display = "none";
    }
  };

  li.appendChild(label);
  li.appendChild(removeBtn);
  list.appendChild(li);
  select.value = "";
}

function isRuleActive(ruleId) {
  return activeAttackerRules.has(ruleId);
}

function calculateDamage() {
const useSimulation = document.getElementById('useSimulation').checked;
  if (useSimulation) {
  runMonteCarloSimulation(); // → wird separat definiert
  return;
  }

  // === INPUTS: Angreifer ===
  const models = +document.getElementById('models').value;
  const attacks = +document.getElementById('attacks').value;
  const impact = +document.getElementById('impact').value;
  const clash = +document.getElementById('cllash').value;
  const cleave = +document.getElementById('cleave').value;
  const brutalImpact = +document.getElementById('brutalImpact').value;
  const trample = +document.getElementById('trample').value;
  const leader = document.getElementById('leader').checked;
  const inspired = document.getElementById('inspired').checked;
const flurry = isRuleActive('flurry');
const relentless = isRuleActive('relentless');
const smite = isRuleActive('smite');
const shock = isRuleActive('shock');
const deadlyBlades = isRuleActive('deadlyBlades');
const gloriousCharge = isRuleActive('gloriousCharge');
const linebreaker = isRuleActive('linebreaker');
const flawless = isRuleActive('flawless');
const attackerBlessed = isRuleActive('blessed');
const opportunists = isRuleActive('opportunists');


  
  const attackerBlessedUsage = document.getElementById('attackerBlessedUsage').value;


  const support = +document.getElementById('support').value;
  const standsInContact = Math.min(models, +document.getElementById('standsInContact').value);
  const nonContactStands = models - standsInContact;


  // === INPUTS: Verteidiger ===
  const defenderStands = +document.getElementById('defenderStands').value;
  const defense = +document.getElementById('defense').value;
  const evasion = +document.getElementById('evasion').value;
  const resolve = +document.getElementById('resolve').value;
  const hardened = +document.getElementById('hardened').value;
  const indomitable = +document.getElementById('indomitable').value;
  const bastion = +document.getElementById('bastion').value;

  const flankRear = document.getElementById('flankRear').checked;
  const ignoreResolve = document.getElementById('ignoreResolve').checked;
  const oblivious = document.getElementById('oblivious').checked;
  const shield = document.getElementById('shield').checked;
  const parry = document.getElementById('parry').checked;
  const phalanx = document.getElementById('phalanx').checked;
  const duelDeclined = document.getElementById('duelDeclined').checked;
  const blessedUsage = document.getElementById('defenderBlessed').value;
  const braveryType = document.getElementById('bravery').value;
  const ignoreTerrifying = braveryType === 'bravery' || braveryType === 'fearless';
  const terrifying = +document.getElementById('terrifying').value;
  const tenacious = +document.getElementById('tenacious').value;
  const untouchable = document.getElementById('untouchable')?.checked || false;

  
  
  
  

  // === RESOLVE BONUS berechnen ===
  let resolveBonus = 0;
  if (defenderStands >= 4 && defenderStands <= 6) resolveBonus = 1;
  else if (defenderStands >= 7 && defenderStands <= 9) resolveBonus = 2;
  else if (defenderStands >= 10) resolveBonus = 3;
  if (phalanx && !flankRear) resolveBonus += 1;
  const effectiveResolve = resolve + resolveBonus;

  // === ANGRIFFE berechnen ===
  let totalAttacks = 0;
  if (attacks > 0) {
    totalAttacks = standsInContact * attacks + nonContactStands * support + (leader ? 1 : 0);
  }

  // === CLASH berechnen ===
  let clashValue = inspired ? Math.min(clash + 1, 4) : clash;
  const rerollSixes = inspired && clash + 1 > 4;
  const baseHitChance = clashValue / 6;

  let hits = totalAttacks * baseHitChance;

  if (rerollSixes) {
  hits += totalAttacks * (1 / 6) * baseHitChance;
  }

  // Reroll-basierte Treffer
  if (!parry && ((attackerBlessed && attackerBlessedUsage === 'normal') || flurry || (opportunists && flankRear))) {
  hits += totalAttacks * (1 - baseHitChance) * baseHitChance;
  }

  // Relentless Blows: 1en unter den erfolgreichen Treffern erzeugen +1 Treffer
  if (relentless) {
  const onesAmongHits = hits * (1 / 6);
  hits += onesAmongHits;
  }

  // === IMPACT ATTACKS berechnen ===
  const totalImpact = models * impact;
  let clashImpact = clash;
  if (gloriousCharge) clashImpact += 1;
  if (shock) clashImpact += 1;
  const impactHitChance = clashImpact / 6;

  let impactHits = totalImpact * impactHitChance;
  if (!parry && ((attackerBlessed && attackerBlessedUsage === 'impact') || flurry || (opportunists && flankRear))) {
    impactHits += totalImpact * (1 - impactHitChance) * impactHitChance;
  }

  // === DEFENSE berechnen ===
  let effectiveDefense = defense;
  if (phalanx && !flankRear) effectiveDefense += 1;
  if (!linebreaker) {
    effectiveDefense += bastion;
    if (shield && !flankRear) effectiveDefense += 1;
  }

  const reducedCleave = Math.max(0, cleave - hardened);
  const reducedBrutalImpact = Math.max(0, brutalImpact - hardened);

  const normalDefense = smite ? 0 : effectiveDefense;
  const saveNormal = Math.max(normalDefense - reducedCleave, evasion);
  const saveImpact = Math.max(effectiveDefense - reducedBrutalImpact, evasion);
  const saveTrample = Math.max(effectiveDefense, evasion);

  let saveChanceNormal = Math.min(saveNormal, 6) / 6;
  let saveChanceImpact = Math.min(saveImpact, 6) / 6;
  let saveChanceTrample = Math.min(saveTrample, 6) / 6;

  // === BLESSED Verteidiger (Reroll Saves) ===
  if (blessedUsage === 'normal') saveChanceNormal += (1 - saveChanceNormal) * saveChanceNormal;
  if (blessedUsage === 'impact') saveChanceImpact += (1 - saveChanceImpact) * saveChanceImpact;
  // === TERRIFYING prüfen ===
  const totalTerrifying = terrifying + (gloriousCharge ? 1 : 0);
  const resolveVal = Math.max(1, effectiveResolve - (ignoreTerrifying ? 0 : totalTerrifying));
  let resolveChance = ignoreResolve ? 1 : Math.min(resolveVal, 5) / 6;
  if (duelDeclined && !ignoreResolve) resolveChance -= (1 / 6) * (1 / 6);
  

  // === Flawless Strikes ===
  const flawlessHits = flawless ? totalAttacks * (1 / 6) : 0;
  const regularHits = hits - flawlessHits;

  const saveChanceFlawless = Math.min(Math.max(evasion, 0), 6) / 6;
  let failedSavesFlawless = flawlessHits * (1 - saveChanceFlawless);
  if (untouchable) {
  const rerollable = failedSavesFlawless * (1 / 6);
  failedSavesFlawless -= rerollable * saveChanceFlawless;
}
  const tenaciousFlawless = Math.min(failedSavesFlawless, tenacious);
  failedSavesFlawless -= tenaciousFlawless;

  let failedResolveFlawless = failedSavesFlawless * (1 - resolveChance);
  if (flankRear && !ignoreResolve) {
    failedResolveFlawless += failedSavesFlawless * resolveChance * (1 - resolveChance);
  }
  failedResolveFlawless = Math.max(0, failedResolveFlawless - indomitable);

  // === Normale Treffer (inkl. Deadly Blades) ===
  let baseFailedSaves = regularHits * (1 - saveChanceNormal);

// Untouchable: 6en erneut würfeln, ca. 1/6 der Fehlschläge
if (untouchable) {
  const rerollable = baseFailedSaves * (1 / 6); // 6en
  baseFailedSaves -= rerollable * saveChanceNormal; // Erfolgreiche Wiederholungen
}

  // Tenacious reduziert echte Fehlschläge
  const tenaciousUsed = Math.min(baseFailedSaves, tenacious);
  baseFailedSaves -= tenaciousUsed;

  let deadlyHits = 0;
  let failedSaves = baseFailedSaves;

  if (deadlyBlades) {
  deadlyHits = baseFailedSaves * (1 / 6);
  failedSaves = deadlyHits * 2 + (baseFailedSaves - deadlyHits);
  }

  let failedResolve = failedSaves * (1 - resolveChance);
  if (flankRear && !ignoreResolve) {
    failedResolve += failedSaves * resolveChance * (1 - resolveChance);
  }
  failedResolve = Math.max(0, failedResolve - indomitable);

  // === IMPACT ===
  let failedImpactSaves = impactHits * (1 - saveChanceImpact);
  const tenaciousImpact = Math.min(failedImpactSaves, tenacious);
  failedImpactSaves -= tenaciousImpact;
  let failedImpactResolve = failedImpactSaves * (1 - resolveChance);
  if (untouchable) {
  const rerollable = failedImpactSaves * (1 / 6);
  failedImpactSaves -= rerollable * saveChanceImpact;
}
  if (flankRear && !ignoreResolve) {
    failedImpactResolve += failedImpactSaves * resolveChance * (1 - resolveChance);
  }
  failedImpactResolve = Math.max(0, failedImpactResolve - indomitable);

  // === TRAMPLE ===
  const trampleHits = models * trample;
  let trampleWounds = trampleHits * (1 - saveChanceTrample);
if (untouchable) {
  const rerollable = trampleWounds * (1 / 6);
  trampleWounds -= rerollable * saveChanceTrample;
}
  const tenaciousTrample = Math.min(trampleWounds, tenacious);
  trampleWounds -= tenaciousTrample;

  // === OBLIVIOUS (modifiziert Resolve-Wunden) ===
  const resolveWoundsNormal = oblivious
    ? Math.ceil((failedResolve + failedResolveFlawless) / 2)
    : failedResolve + failedResolveFlawless;

  const resolveWoundsImpact = oblivious
    ? Math.ceil(failedImpactResolve / 2)
    : failedImpactResolve;

  const totalWoundsNormal = failedSaves + failedSavesFlawless + resolveWoundsNormal;
  const totalWoundsImpact = failedImpactSaves + resolveWoundsImpact;
  const totalWounds = totalWoundsNormal + totalWoundsImpact + trampleWounds;
  // === AUSGABE vorbereiten ===
  let resultText = '';

  // Normale Angriffe
  if (totalAttacks > 0) {
    resultText += `--- Normal Attack ---\n` +
      `Hits: ${(regularHits + flawlessHits).toFixed(1)}\n` +
      `Failed Saves: ${(failedSaves + failedSavesFlawless).toFixed(1)}${blessedUsage === 'normal' ? ' (Defender Blessed)' : ''}${attackerBlessed && attackerBlessedUsage === 'normal' ? ' (Attacker Blessed)' : ''}${flawless ? ' (Flawless Strikes)' : ''}\n` +
      `Failed Resolve: ${(failedResolve + failedResolveFlawless).toFixed(1)}\n` +
      `Wounds: ${totalWoundsNormal.toFixed(1)}\n\n`;
  }

  // Impact-Angriffe
  if (totalImpact > 0) {
    resultText += `--- Impact Attack ---\n` +
      `Hits: ${impactHits.toFixed(1)}\n` +
      `Failed Saves: ${failedImpactSaves.toFixed(1)}${blessedUsage === 'impact' ? ' (Defender Blessed)' : ''}${attackerBlessed && attackerBlessedUsage === 'impact' ? ' (Attacker Blessed)' : ''}\n` +
      `Failed Resolve: ${failedImpactResolve.toFixed(1)}\n` +
      `Wounds: ${totalWoundsImpact.toFixed(1)}\n\n`;
  }

  // Trample
  if (trampleHits > 0) {
    resultText += `--- Trample ---\n` +
      `Auto-Hits (from ${models} stands): ${trampleHits}\n` +
      `Failed Saves: ${trampleWounds.toFixed(1)}\n` +
      `Wounds: ${trampleWounds.toFixed(1)}\n\n`;
  }

  // Gesamtübersicht
  resultText += `--- Total Damage ---\n` +
    `Overall Wounds: ${totalWounds.toFixed(1)}`;

  // Ausgabe setzen
  document.getElementById('result').innerText = resultText;
  // Chart erzeugen
const ctx = document.getElementById('woundChart').getContext('2d');

// Häufigkeiten berechnen
const woundCounts = {};
results.forEach(w => {
  woundCounts[w] = (woundCounts[w] || 0) + 1;
});

const sortedKeys = Object.keys(woundCounts).map(Number).sort((a, b) => a - b);
const frequencies = sortedKeys.map(k => woundCounts[k]);

// Falls ein alter Chart existiert → zerstören
if (window.woundChartInstance) {
  window.woundChartInstance.destroy();
}

// Neuen Chart erzeugen
window.woundChartInstance = new Chart(ctx, {
  type: 'bar',
  data: {
    labels: sortedKeys,
    datasets: [{
      label: 'Wound Frequency',
      data: frequencies,
      backgroundColor: '#4caf50'
    }]
  },
  options: {
    responsive: true,
    plugins: {
      legend: { display: false },
      title: {
        display: true,
        text: 'Wound Distribution (10,000 rolls)'
      }
    },
    scales: {
      x: {
        title: { display: true, text: 'Wounds' }
      },
      y: {
        title: { display: true, text: 'Frequency' },
        beginAtZero: true
      }
    }
  }
});

}
function runMonteCarloSimulation() {
  const iterations = 10000;
  const results = [];

  // Eingaben lesen
  const models = +document.getElementById('models').value;
  const attacks = +document.getElementById('attacks').value;
  const impact = +document.getElementById('impact').value;
  const clash = +document.getElementById('cllash').value;
  const cleave = +document.getElementById('cleave').value;
  const brutalImpact = +document.getElementById('brutalImpact').value;
  const defense = +document.getElementById('defense').value;
  const evasion = +document.getElementById('evasion').value;
  const resolve = +document.getElementById('resolve').value;
  const hardened = +document.getElementById('hardened').value;
  const tenacious = +document.getElementById('tenacious')?.value || 0;
  const indomitable = +document.getElementById('indomitable')?.value || 0;
  const trample = +document.getElementById('trample').value;
  const shield = document.getElementById('shield')?.checked || false;
  const flankRear = document.getElementById('flankRear').checked;
  const inspired = document.getElementById('inspired').checked;
  const leader = document.getElementById('leader').checked;
  const support = +document.getElementById('support').value;
  const untouchable = document.getElementById('untouchable')?.checked || false;
  const flurry = isRuleActive('flurry');
  const relentless = isRuleActive('relentless');
  const smite = isRuleActive('smite');
  const shock = isRuleActive('shock');
  const deadlyBlades = isRuleActive('deadlyBlades');
  const gloriousCharge = isRuleActive('gloriousCharge');
  const linebreaker = isRuleActive('linebreaker');
  const flawless = isRuleActive('flawless');
  const attackerBlessed = isRuleActive('blessed');
  const opportunists = isRuleActive('opportunists');
  const oblivious = document.getElementById('oblivious')?.checked || false;

  const attackerBlessedUsage = document.getElementById('attackerBlessedUsage').value;
  const parry = document.getElementById('parry')?.checked || false;

  const inspiredClash = inspired ? Math.min(clash + 1, 4) : clash;
  const clashImpact = shock ? inspiredClash + 1 : inspiredClash;

  const standsInContact = +document.getElementById('standsInContact').value;
  const nonContactStands = models - standsInContact;
  const totalAttacks = attacks > 0 ? standsInContact * attacks + nonContactStands * support + (leader ? 1 : 0) : 0;

  for (let i = 0; i < iterations; i++) {
    let simWounds = 0;

    // Beispielhafte Angriffssimulation (normale Treffer)
    let hits = 0;
    for (let j = 0; j < totalAttacks; j++) {
      let roll = Math.ceil(Math.random() * 6);
      let hit = roll <= inspiredClash;

      if (!hit && !parry && (
        (attackerBlessed && attackerBlessedUsage === 'normal') || flurry || (opportunists && flankRear))) {
        roll = Math.ceil(Math.random() * 6);
        hit = roll <= inspiredClash;
      }

      if (hit) {
        hits++;
        if (relentless && roll === 1) hits++;
      }
    }

    const flawlessHits = flawless ? Math.floor(hits * (1 / 6)) : 0;
    const regularHits = hits - flawlessHits;

    let saveTarget = Math.max((smite ? 0 : defense) - cleave - hardened, evasion);
    let failedSaves = 0;
    for (let j = 0; j < regularHits; j++) {
      let saveRoll = Math.ceil(Math.random() * 6);
      if (saveRoll > saveTarget) {
        if (untouchable && saveRoll === 6) {
          const reroll = Math.ceil(Math.random() * 6);
          if (reroll > saveTarget) failedSaves++;
        } else {
          failedSaves++;
        }
      }
    }

    const tenaciousNormal = Math.min(failedSaves, tenacious);
    failedSaves -= tenaciousNormal;

    if (deadlyBlades) {
      const deadly = Math.floor(failedSaves * (1 / 6));
      failedSaves += deadly;
    }

    let saveFlawlessTarget = Math.max(evasion - hardened, 0);
    let failedFlawless = 0;
    for (let j = 0; j < flawlessHits; j++) {
      let roll = Math.ceil(Math.random() * 6);
      let fail = roll > saveFlawlessTarget;

      if (fail && untouchable && roll === 6) {
        const reroll = Math.ceil(Math.random() * 6);
        fail = reroll > saveFlawlessTarget;
      }

      if (fail) failedFlawless++;
    }

    const tenaciousFlawless = Math.min(failedFlawless, tenacious);
    failedFlawless -= tenaciousFlawless;

    // === Impact ===
    const totalImpact = models * impact;
    let impactHits = 0;
    for (let j = 0; j < totalImpact; j++) {
      let roll = Math.ceil(Math.random() * 6);
      let hit = roll <= clashImpact;

      if (!hit && !parry && (
        (attackerBlessed && attackerBlessedUsage === 'impact') || flurry || (opportunists && flankRear))) {
        roll = Math.ceil(Math.random() * 6);
        hit = roll <= clashImpact;
      }

      if (hit) impactHits++;
    }

    let saveImpactTarget = Math.max(defense - brutalImpact - hardened, evasion);
    let failedImpact = 0;
    for (let j = 0; j < impactHits; j++) {
      const roll = Math.ceil(Math.random() * 6);
      if (roll > saveImpactTarget) {
        if (untouchable && roll === 6) {
          const reroll = Math.ceil(Math.random() * 6);
          if (reroll > saveImpactTarget) failedImpact++;
        } else {
          failedImpact++;
        }
      }
    }

    const tenaciousImpact = Math.min(failedImpact, tenacious);
    failedImpact -= tenaciousImpact;

    // === Trample ===
    const trampleHits = models * trample;
    let saveTrampleTarget = Math.max(defense - hardened, evasion);
    let failedTrample = 0;
    for (let j = 0; j < trampleHits; j++) {
      const roll = Math.ceil(Math.random() * 6);
      if (roll > saveTrampleTarget) {
        if (untouchable && roll === 6) {
          const reroll = Math.ceil(Math.random() * 6);
          if (reroll > saveTrampleTarget) failedTrample++;
        } else {
          failedTrample++;
        }
      }
    }

    const tenaciousTrample = Math.min(failedTrample, tenacious);
    failedTrample -= tenaciousTrample;

    // === Resolve ===
    const resolveTarget = Math.min(resolve, 5);
    let failedResolve = 0;

    for (let j = 0; j < (failedSaves + failedFlawless + failedImpact); j++) {
      if (Math.ceil(Math.random() * 6) > resolveTarget) failedResolve++;
    }

    failedResolve = Math.max(0, failedResolve - indomitable);
    const resolveWounds = oblivious ? Math.ceil(failedResolve / 2) : failedResolve;

    // === Total ===
    simWounds = failedSaves + failedFlawless + failedImpact + failedTrample + resolveWounds;
    results.push(simWounds);
  }

  results.sort((a, b) => a - b);
  const avg = results.reduce((a, b) => a + b, 0) / iterations;
  const median = results[Math.floor(results.length / 2)];
  const mode = results.sort((a, b) =>
    results.filter(v => v === a).length - results.filter(v => v === b).length
  ).pop();

  const resultText = `--- Simulation Results (10,000 rolls) ---\n` +
    `Average Wounds: ${avg.toFixed(2)}\n` +
    `Median: ${median}\n` +
    `Mode (most frequent): ${mode}`;

  document.getElementById('result').innerText = resultText;
  // Chart erzeugen
const ctx = document.getElementById('woundChart').getContext('2d');

// Häufigkeiten berechnen
const woundCounts = {};
results.forEach(w => {
  woundCounts[w] = (woundCounts[w] || 0) + 1;
});

const sortedKeys = Object.keys(woundCounts).map(Number).sort((a, b) => a - b);
const frequencies = sortedKeys.map(k => woundCounts[k]);

// Falls ein alter Chart existiert → zerstören
if (window.woundChartInstance) {
  window.woundChartInstance.destroy();
}

// Neuen Chart erzeugen
window.woundChartInstance = new Chart(ctx, {
  type: 'bar',
  data: {
    labels: sortedKeys,
    datasets: [{
      label: 'Wound Frequency',
      data: frequencies,
      backgroundColor: '#4caf50'
    }]
  },
  options: {
    responsive: true,
    plugins: {
      legend: { display: false },
      title: {
        display: true,
        text: 'Wound Distribution (10,000 rolls)'
      }
    },
    scales: {
      x: {
        title: { display: true, text: 'Wounds' }
      },
      y: {
        title: { display: true, text: 'Frequency' },
        beginAtZero: true
      }
    }
  }
});

}


</script>
</body>
</html>
